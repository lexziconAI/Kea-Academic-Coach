<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kea V7 - Turn-Taking Architecture</title>
    <style>
        :root {
            --kea-green: #4CAF50;
            --kea-dark: #1a1a2e;
            --kea-light: #16213e;
            --kea-accent: #e94560;
            --kea-gold: #f39c12;
            --kea-blue: #3498db;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--kea-dark) 0%, var(--kea-light) 100%);
            min-height: 100vh;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: white;
            padding: 25px 40px;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .header h1 {
            font-size: 2.2em;
            margin-bottom: 8px;
            color: #333;
        }
        
        .header .features {
            color: #666;
            font-size: 0.95em;
        }
        
        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .status-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
            transition: background 0.3s;
        }
        
        .status-dot.connected { background: var(--kea-green); }
        .status-dot.speaking { background: var(--kea-accent); animation: pulse 0.5s infinite; }
        .status-dot.listening { background: var(--kea-green); animation: pulse 0.8s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }
        


        .mic-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(145deg, var(--kea-green), #45a049);
            color: white;
            font-size: 3em;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.3);
            margin: 20px auto;
            display: block;
            position: relative;
        }
        
        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(76, 175, 80, 0.4);
        }
        
        .mic-button.active {
            background: linear-gradient(145deg, var(--kea-blue), #2980b9);
            animation: mic-active 1.5s infinite;
        }
        
        .mic-button.speaking {
            background: linear-gradient(145deg, var(--kea-accent), #c0392b);
            cursor: not-allowed;
            animation: none;
            opacity: 0.8;
        }
        
        .mic-icon {
            transition: all 0.3s;
        }
        
        .mic-button.speaking .mic-icon {
            content: 'üîá';
        }
        
        @keyframes mic-active {
            0%, 100% { box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.7); }
            50% { box-shadow: 0 0 0 30px rgba(52, 152, 219, 0); }
        }
        
        .visualizer {
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .visualizer canvas {
            width: 100%;
            height: 100%;
        }
        
        .chat-panel {
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        /* Quick Prompt Buttons */
        .quick-prompts {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .quick-prompt-btn {
            background: rgba(76, 175, 80, 0.15);
            border: 1px solid rgba(76, 175, 80, 0.3);
            color: var(--kea-green);
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quick-prompt-btn:hover {
            background: rgba(76, 175, 80, 0.3);
            transform: translateY(-2px);
        }
        
        .quick-prompt-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Summary Panel */
        .summary-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }
        
        .summary-panel.active {
            display: block;
        }
        
        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }
        
        .summary-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--kea-green);
        }
        
        .summary-actions {
            display: flex;
            gap: 10px;
        }
        
        .summary-btn {
            background: var(--kea-green);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .summary-btn:hover {
            background: #66bb6a;
            transform: translateY(-1px);
        }
        
        .summary-btn.secondary {
            background: rgba(255,255,255,0.1);
            color: #ccc;
        }
        
        .summary-content {
            color: #e0e0e0;
            line-height: 1.6;
        }
        
        .summary-content h2 {
            color: var(--kea-green);
            font-size: 16px;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(76, 175, 80, 0.3);
        }
        
        .summary-content h3 {
            color: var(--kea-blue);
            font-size: 14px;
            margin: 12px 0 8px 0;
        }
        
        .summary-content ul {
            margin: 8px 0;
            padding-left: 20px;
        }
        
        .summary-content li {
            margin: 5px 0;
            color: #bbb;
        }
        
        .summary-content li::marker {
            color: var(--kea-green);
        }
        
        .summary-loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }
        
        .summary-loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        @media print {
            body { background: white; color: black; }
            .header, .upload-panel, .mic-button, .visualizer, 
            .status-panel, .quick-prompts, .summary-actions, .traffic-light { display: none !important; }
            .summary-panel { display: block !important; background: white; }
            .summary-content h2 { color: #2e7d32; }
            .summary-content h3 { color: #1565c0; }
            .summary-content li { color: #333; }
        }
        
        .chat-message {
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 15px;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .chat-message.user {
            background: rgba(76, 175, 80, 0.2);
            margin-left: 50px;
        }
        
        .chat-message.assistant {
            background: rgba(52, 152, 219, 0.2);
            margin-right: 50px;
        }
        
        .chat-message .speaker {
            font-size: 0.8em;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .traffic-light {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 30px;
            width: fit-content;
            margin: 0 auto 20px auto;
        }
        
        .light {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #333;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
        }
        
        .light.green.active { background: var(--kea-green); box-shadow: 0 0 20px var(--kea-green); }
        .light.red.active { background: var(--kea-accent); box-shadow: 0 0 20px var(--kea-accent); }
        
        .state-label {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            height: 1.5em;
        }
        
        /* Upload Panel Styles */
        .upload-panel {
            background: rgba(255, 255, 255, 0.08);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .upload-panel:hover {
            border-color: var(--kea-green);
            background: rgba(76, 175, 80, 0.1);
        }
        
        .upload-panel.dragover {
            border-color: var(--kea-gold);
            background: rgba(243, 156, 18, 0.2);
        }
        
        .upload-panel.uploaded {
            border-color: var(--kea-green);
            border-style: solid;
            background: rgba(76, 175, 80, 0.15);
        }
        
        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }
        
        .upload-title {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .upload-subtitle {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 15px;
        }
        
        .upload-formats {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .format-badge {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            color: #ccc;
        }
        
        .upload-input {
            display: none;
        }
        
        .upload-progress {
            display: none;
            margin-top: 15px;
        }
        
        .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--kea-green);
            width: 0%;
            transition: width 0.3s;
        }
        
        .upload-status {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--kea-gold);
        }
        
        .upload-result {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 10px;
            text-align: left;
        }
        
        .upload-result .org-name {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--kea-green);
        }
        
        .upload-result .stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.9em;
            color: #ccc;
        }
        
        .skip-upload {
            margin-top: 15px;
            background: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #aaa;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        
        .skip-upload:hover {
            border-color: white;
            color: white;
        }
        
        .voice-section {
            display: none;
        }
        
        .voice-section.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="axiom-logo.png" alt="Axiom Intelligence" style="height: 120px; margin-bottom: 15px;">
        <h1>Kea Academic Coach</h1>
        <div class="powered-by" style="font-size: 0.95em; color: #666; margin-bottom: 8px;">Powered by <strong style="color: var(--kea-green);">Axiom Intelligence</strong></div>
        <div class="features">Interactive Oral Assessments as a Service (IOAaaS)</div>
    </div>
    
    <div class="container">
        <!-- Upload Panel (shown first) -->
        <div id="upload-panel" class="panel upload-panel">
            <div class="upload-icon">üìÑ</div>
            <div class="upload-title">Upload Your Assessment</div>
            <div class="upload-subtitle">Drop your sustainability report here or click to browse</div>
            <input type="file" id="file-input" class="upload-input" accept=".docx,.pdf,.txt">
            <div class="upload-formats">
                <span class="format-badge">.docx</span>
                <span class="format-badge">.pdf</span>
                <span class="format-badge">.txt</span>
            </div>
            <div id="upload-progress" class="upload-progress">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <div id="upload-status" class="upload-status">Uploading...</div>
            </div>
            <div id="upload-result" class="upload-result">
                <div id="org-name" class="org-name"></div>
                <div class="stats">
                    <span>üìù <span id="word-count">0</span> words</span>
                    <span>üéØ <span id="dev-areas">0</span> development areas</span>
                    <span>‚ú® <span id="strengths">0</span> strengths</span>
                </div>
            </div>
            <button id="skip-upload" class="skip-upload">Skip ‚Üí Start without upload</button>
        </div>
        
        <!-- Voice Section (hidden until upload or skip) -->
        <div id="voice-section" class="voice-section">
            <!-- Traffic Light Indicator -->
            <div class="traffic-light">
                <div id="light-listening" class="light green">üëÇ</div>
                <div id="light-speaking" class="light red">üó£Ô∏è</div>
            </div>
            <div id="state-label" class="state-label">Ready to Connect</div>


        
        <div class="panel">
            <button id="mic-btn" class="mic-button">üé§</button>
            <div class="visualizer">
                <canvas id="audio-viz"></canvas>
            </div>
        </div>
        
        <!-- Quick Prompt Buttons -->
        <div class="panel">
            <div style="font-size: 12px; color: #888; margin-bottom: 10px;">üí° Quick prompts (click to send):</div>
            <div class="quick-prompts" id="quick-prompts">
                <button class="quick-prompt-btn" data-prompt="Can you explain what you mean by that?">ü§î Explain more</button>
                <button class="quick-prompt-btn" data-prompt="Can you give me an example?">üìù Give example</button>
                <button class="quick-prompt-btn" data-prompt="How could I improve this section?">üéØ How to improve</button>
                <button class="quick-prompt-btn" data-prompt="What evidence would strengthen my argument?">üìä Need evidence</button>
                <button class="quick-prompt-btn" data-prompt="Can you help me think about the stakeholders involved?">üë• Stakeholders</button>
                <button class="quick-prompt-btn" data-prompt="What are the gaps in my analysis?">üîç Find gaps</button>
                <button class="quick-prompt-btn" data-prompt="How does this connect to the strategies I proposed?">üîó Connect strategy</button>
                <button class="quick-prompt-btn" data-prompt="What would make my implementation plan more realistic?">‚öôÔ∏è Implementation</button>
            </div>
        </div>
        
        <div class="panel chat-panel" id="chat-box">
            <!-- Messages will appear here -->
        </div>
        
        <!-- Summary Toggle Button (always visible after first exchange) -->
        <div class="panel" id="summary-toggle-panel" style="display: none;">
            <button class="summary-btn" onclick="toggleSummary()" id="summary-toggle-btn" style="width: 100%;">
                üìã Show Key Takeaways
            </button>
        </div>
        
        <!-- Key Takeaways Summary Panel -->
        <div class="summary-panel" id="summary-panel">
            <div class="summary-header">
                <div class="summary-title">üìã Key Takeaways</div>
                <div class="summary-actions">
                    <button class="summary-btn secondary" onclick="toggleSummary()">Hide</button>
                    <button class="summary-btn" onclick="printSummary()">üñ®Ô∏è Print PDF</button>
                </div>
            </div>
            <div class="summary-content" id="summary-content">
                <!-- AI-generated summary will appear here -->
            </div>
        </div>
        
        <div class="panel status-panel">
            <div class="status-item">
                <div id="status-dot" class="status-dot"></div>
                <span id="status-text">Disconnected</span>
            </div>
            <div class="status-item">
                <span>Latency:</span>
                <span id="latency-display">0ms</span>
            </div>
        </div>
        </div> <!-- End voice-section -->
    </div>

    <script src="kea_v7_anti_hallucination.js"></script>
    <script>
        // Configuration - use wss:// for HTTPS, ws:// for HTTP
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const WS_URL = `${wsProtocol}//${window.location.host}/relay-v7`;
        
        // Session & Coaching Context
        const sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        let coachingContext = null;
        let openingQuestion = null;
        
        // Conversation History for Summary
        let conversationHistory = [];
        let summaryUpdatePending = false;
        
        // State
        let ws = null;
        let audioContext = null;
        let audioWorkletNode = null;
        let mediaStream = null;
        let isRecording = false;
        let isSystemSpeaking = false;
        let audioQueue = [];
        let isPlaying = false;
        
        // Anti-Hallucination Gate
        let audioGate = null;
        
        // Upload UI Elements
        const uploadPanel = document.getElementById('upload-panel');
        const voiceSection = document.getElementById('voice-section');
        const fileInput = document.getElementById('file-input');
        const uploadProgress = document.getElementById('upload-progress');
        const progressFill = document.getElementById('progress-fill');
        const uploadStatus = document.getElementById('upload-status');
        const uploadResult = document.getElementById('upload-result');
        const skipUpload = document.getElementById('skip-upload');
        
        // Voice UI Elements
        const micBtn = document.getElementById('mic-btn');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const chatBox = document.getElementById('chat-box');
        const canvas = document.getElementById('audio-viz');
        const ctx = canvas.getContext('2d');
        const latencyDisplay = document.getElementById('latency-display');
        const lightListening = document.getElementById('light-listening');
        const lightSpeaking = document.getElementById('light-speaking');
        const stateLabel = document.getElementById('state-label');
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UPLOAD HANDLERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Click to upload
        uploadPanel.addEventListener('click', (e) => {
            if (e.target !== skipUpload && !e.target.closest('.skip-upload')) {
                fileInput.click();
            }
        });
        
        // Drag and drop
        uploadPanel.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadPanel.classList.add('dragover');
        });
        
        uploadPanel.addEventListener('dragleave', () => {
            uploadPanel.classList.remove('dragover');
        });
        
        uploadPanel.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadPanel.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileUpload(files[0]);
            }
        });
        
        // File input change
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileUpload(e.target.files[0]);
            }
        });
        
        // Skip upload
        skipUpload.addEventListener('click', (e) => {
            e.stopPropagation();
            showVoiceSection();
        });
        
        async function handleFileUpload(file) {
            console.log(`[UPLOAD] Starting upload: ${file.name} (${Math.round(file.size/1024)}KB)`);
            
            // Show progress
            uploadProgress.style.display = 'block';
            progressFill.style.width = '0%';
            uploadStatus.textContent = 'Uploading...';
            
            try {
                // Create form data
                const formData = new FormData();
                formData.append('file', file);
                formData.append('sessionId', sessionId);
                
                // Animate progress
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress = Math.min(progress + 10, 90);
                    progressFill.style.width = progress + '%';
                }, 200);
                
                // Upload
                const response = await fetch('/api/upload-assessment', {
                    method: 'POST',
                    body: formData
                });
                
                clearInterval(progressInterval);
                progressFill.style.width = '100%';
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Upload failed');
                }
                
                const result = await response.json();
                console.log('[UPLOAD] Success:', result);
                
                // Store coaching context
                openingQuestion = result.openingQuestion;
                
                // Show result
                uploadStatus.textContent = 'Analysis complete!';
                uploadStatus.style.color = 'var(--kea-green)';
                uploadResult.style.display = 'block';
                document.getElementById('org-name').textContent = 'üìä ' + result.organization;
                document.getElementById('word-count').textContent = result.wordCount;
                document.getElementById('dev-areas').textContent = result.developmentAreas;
                document.getElementById('strengths').textContent = result.strengths;
                
                // Display FRACTAL METADATA to prove full decomposition
                if (result.fractalMetadata) {
                    const fm = result.fractalMetadata;
                    console.log('üåÄ FRACTAL DECOMPOSITION PROOF:');
                    console.log('   Method:', fm.method);
                    console.log('   Paths Generated:', fm.pathsGenerated);
                    console.log('   Paths Survived Pruning:', fm.pathsSurvived);
                    console.log('   Paths Passed Yamas:', fm.pathsPassed);
                    console.log('   Winner Path:', fm.winnerPath);
                    console.log('   Winner Score:', fm.winnerScore?.toFixed(4));
                    console.log('   Bellman Value:', fm.bellmanValue?.toFixed(4));
                    console.log('   Total Time:', fm.totalTimeMs + 'ms');
                    if (fm.yamasScores) {
                        console.log('üïâÔ∏è YAMAS SCORES:');
                        console.log('   Ahimsa (Compassion):', (fm.yamasScores.ahimsa * 100).toFixed(0) + '%');
                        console.log('   Satya (Truth):', (fm.yamasScores.satya * 100).toFixed(0) + '%');
                        console.log('   Asteya (Respect):', (fm.yamasScores.asteya * 100).toFixed(0) + '%');
                        console.log('   Brahmacharya (Ethics):', (fm.yamasScores.brahmacharya * 100).toFixed(0) + '%');
                        console.log('   Aparigraha (Adaptability):', (fm.yamasScores.aparigraha * 100).toFixed(0) + '%');
                    }
                    
                    // Add visual indicator
                    const fractalInfo = document.createElement('div');
                    fractalInfo.style.cssText = 'margin-top: 12px; padding: 10px; background: rgba(139, 195, 74, 0.1); border-radius: 8px; font-size: 11px; color: var(--kea-green);';
                    fractalInfo.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 6px;">üåÄ Fractal Decomposition Complete</div>
                        <div>Method: ${fm.method}</div>
                        <div>Paths: ${fm.pathsGenerated} ‚Üí ${fm.pathsSurvived} (pruned) ‚Üí ${fm.pathsPassed} (passed)</div>
                        <div>Winner: Path #${fm.winnerPath} (score: ${fm.winnerScore?.toFixed(3)})</div>
                        <div>Time: ${fm.totalTimeMs}ms</div>
                    `;
                    uploadResult.appendChild(fractalInfo);
                }
                
                uploadPanel.classList.add('uploaded');
                
                // Auto-transition to voice after 2 seconds
                setTimeout(() => {
                    showVoiceSection();
                }, 2000);
                
            } catch (error) {
                console.error('[UPLOAD] Error:', error);
                uploadStatus.textContent = '‚ùå ' + error.message;
                uploadStatus.style.color = 'var(--kea-accent)';
                progressFill.style.background = 'var(--kea-accent)';
            }
        }
        
        function showVoiceSection() {
            uploadPanel.style.display = 'none';
            voiceSection.classList.add('active');
            
            // If we have an opening question, show it
            if (openingQuestion) {
                addMessage('assistant', openingQuestion);
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // VOICE HANDLERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Initialize
        micBtn.addEventListener('click', toggleRecording);
        
        function updateState(state) {
            lightListening.classList.remove('active');
            lightSpeaking.classList.remove('active');
            micBtn.classList.remove('active', 'speaking');
            micBtn.innerHTML = 'üé§';
            
            if (state === 'listening') {
                lightListening.classList.add('active');
                stateLabel.innerText = "Listening...";
                stateLabel.style.color = "var(--kea-green)";
                micBtn.classList.add('active');
                isSystemSpeaking = false;
                
                // Reset playback queue when we start listening
                if (audioContext) {
                    nextStartTime = audioContext.currentTime;
                }
                
                // RESUME MICROPHONE
                if (audioWorkletNode) {
                    audioWorkletNode.port.postMessage({ type: 'mute', muted: false });
                }
            } 
            else if (state === 'speaking') {
                lightSpeaking.classList.add('active');
                stateLabel.innerText = "System Speaking";
                stateLabel.style.color = "var(--kea-accent)";
                micBtn.classList.add('speaking');
                micBtn.innerHTML = 'üîá';
                isSystemSpeaking = true;
                
                // MUTE MICROPHONE (Sensory Gating)
                if (audioWorkletNode) {
                    audioWorkletNode.port.postMessage({ type: 'mute', muted: true });
                }
                
                // RESET AUDIO GATE BUFFER (Prevent TTS from being captured)
                if (audioGate) {
                    audioGate.reset();
                }
            }
            else {
                stateLabel.innerText = "Ready";
                stateLabel.style.color = "white";
            }
        }

        async function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }
        
        async function startRecording() {
            try {
                if (!audioContext) {
                    // Use default sample rate (usually 44.1k or 48k) for high quality output
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Add timestamp to force reload of worklet file (bypass cache)
                    await audioContext.audioWorklet.addModule(`audio-worklet.js?t=${Date.now()}`);
                }
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Check if getUserMedia is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("Browser API 'navigator.mediaDevices.getUserMedia' is not available. Are you on HTTPS or localhost?");
                }

                mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: false, // We handle gating manually
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                connectWebSocket();
                
                // Initialize Audio Gate
                audioGate = new AudioGateClient({
                    minDurationMs: 500,
                    minEnergy: 0.005,
                    minDbAboveNoise: 10,
                    onSpeechComplete: (combinedAudio, duration) => {
                        if (ws && ws.readyState === WebSocket.OPEN && !isSystemSpeaking) {
                            // Convert Int16 to Float32 for server compatibility
                            const floatAudio = new Float32Array(combinedAudio.length);
                            for(let i=0; i<combinedAudio.length; i++) {
                                floatAudio[i] = combinedAudio[i] / 32768.0;
                            }
                            
                            // Send as a single large chunk
                            ws.send(JSON.stringify({
                                type: 'audio_chunk',
                                audio: arrayBufferToBase64(floatAudio.buffer),
                                timestamp: Date.now()
                            }));
                            console.log(`[GATE] Sent ${duration}ms of speech`);
                        }
                    },
                    onDropped: (duration) => {
                        console.log(`[GATE] Dropped ${duration}ms (noise/short)`);
                    }
                });

                const source = audioContext.createMediaStreamSource(mediaStream);
                audioWorkletNode = new AudioWorkletNode(audioContext, 'audio-processor');
                
                // Send sample rate to worklet
                audioWorkletNode.port.postMessage({ 
                    type: 'browserSampleRate', 
                    rate: audioContext.sampleRate 
                });

                source.connect(audioWorkletNode);
                // audioWorkletNode.connect(audioContext.destination); // Removed to prevent feedback
                
                audioWorkletNode.port.onmessage = (event) => {
                    if (event.data.type === 'audio') {
                        // Visualizer always runs
                        drawVisualizer(event.data.buffer);
                        
                        // Only process if system is NOT speaking (Client-side Gating)
                        if (!isSystemSpeaking && audioGate) {
                            // Convert Float32 to Int16 for AudioGate
                            const float32 = new Float32Array(event.data.buffer);
                            const int16 = new Int16Array(float32.length);
                            for (let i = 0; i < float32.length; i++) {
                                const s = Math.max(-1, Math.min(1, float32[i]));
                                int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                            }
                            
                            audioGate.processChunk(int16);
                        }
                    }
                };
                
                isRecording = true;
                updateState('listening');
                statusText.innerText = "Connected";
                statusDot.className = "status-dot connected";
                
            } catch (error) {
                console.error('Error starting recording:', error);
                alert(`Could not access microphone: ${error.name} - ${error.message}`);
            }
        }
        
        function stopRecording() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            if (ws) {
                ws.close();
            }
            if (audioWorkletNode) {
                audioWorkletNode.disconnect();
            }
            
            isRecording = false;
            micBtn.classList.remove('active', 'speaking');
            statusText.innerText = "Disconnected";
            statusDot.className = "status-dot";
            updateState('idle');
        }
        
        function connectWebSocket() {
            ws = new WebSocket(WS_URL);
            
            ws.onopen = () => {
                console.log('WebSocket connected');
                console.log('[WS] Sending init with sessionId:', sessionId);
                ws.send(JSON.stringify({ type: 'init', sessionId: sessionId }));
            };
            
            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                
                switch (data.type) {
                    case 'coaching_context_loaded':
                        console.log('‚úÖ COACHING CONTEXT LOADED INTO GROQ BRAIN!');
                        console.log('   Organization:', data.organization);
                        break;
                        
                    case 'state':
                        // Only handle 'speaking' state from server
                        // 'listening' state is controlled by playback completion
                        if (data.state === 'speaking') {
                            updateState(data.state);
                        }
                        // Ignore 'listening' from server - let playback tracker handle it
                        break;
                        
                    case 'transcript':
                        addMessage('user', data.text);
                        conversationHistory.push({ role: 'user', text: data.text });
                        break;
                        
                    case 'response':
                        addMessage('assistant', data.text);
                        conversationHistory.push({ role: 'assistant', text: data.text });
                        // Trigger summary update after each AI response
                        updateSummary();
                        break;
                        
                    case 'audio_chunk':
                        playAudioChunk(data.audio);
                        if (data.latency) {
                            latencyDisplay.innerText = `${data.latency}ms`;
                        }
                        break;
                        
                    case 'speech_complete':
                        // Server says TTS generation is done, but audio may still be playing
                        // Don't switch to listening yet - let playback tracker handle it
                        console.log('[SERVER] TTS generation complete, waiting for playback...');
                        break;
                        
                    case 'status':
                        statusText.innerText = data.stage;
                        break;
                }
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected');
                if (isRecording) stopRecording();
            };
        }
        
        // Audio Playback Queue with proper gating
        let nextStartTime = 0;
        let playbackEndTime = 0; // Track when ALL audio will finish
        let playbackCheckInterval = null;

        async function playAudioChunk(base64Audio) {
            if (!audioContext) return;

            const audioData = base64ToArrayBuffer(base64Audio);
            const audioBuffer = await audioContext.decodeAudioData(audioData);
            
            // Apply fade in/out directly to the audio buffer to prevent clicks
            const fadeSamples = Math.min(Math.floor(audioBuffer.sampleRate * 0.015), audioBuffer.length / 4); // 15ms fade
            
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const data = audioBuffer.getChannelData(channel);
                
                // Fade in
                for (let i = 0; i < fadeSamples; i++) {
                    data[i] *= i / fadeSamples;
                }
                
                // Fade out
                for (let i = 0; i < fadeSamples; i++) {
                    data[data.length - 1 - i] *= i / fadeSamples;
                }
            }
            
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            
            const currentTime = audioContext.currentTime;
            // Schedule for next available slot
            const startTime = Math.max(currentTime + 0.02, nextStartTime);
            
            source.start(startTime);
            
            // Update next start time
            nextStartTime = startTime + audioBuffer.duration;
            
            // Track the absolute end time of all scheduled audio
            playbackEndTime = Math.max(playbackEndTime, startTime + audioBuffer.duration);
            
            // Ensure we're in speaking state while audio is playing
            if (!isSystemSpeaking) {
                isSystemSpeaking = true;
                updateState('speaking');
            }
            
            // Start polling to detect when playback is complete
            if (!playbackCheckInterval) {
                playbackCheckInterval = setInterval(() => {
                    if (audioContext && audioContext.currentTime >= playbackEndTime) {
                        // All audio has finished playing
                        clearInterval(playbackCheckInterval);
                        playbackCheckInterval = null;
                        
                        // Add 500ms buffer after audio ends before listening
                        setTimeout(() => {
                            if (isSystemSpeaking) {
                                isSystemSpeaking = false;
                                updateState('listening');
                                console.log('[PLAYBACK] Audio complete, resuming listening');
                            }
                        }, 500);
                    }
                }, 100);
            }
        }
        
        function addMessage(role, text) {
            const div = document.createElement('div');
            div.className = `chat-message ${role}`;
            div.innerHTML = `
                <div class="speaker">${role === 'user' ? 'You' : 'Kea'}</div>
                <div class="text">${text}</div>
            `;
            chatBox.appendChild(div);
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        

        
        // Helpers
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Float32Array(buffer);
            const len = bytes.byteLength;
            const view = new Uint8Array(buffer);
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(view[i]);
            }
            return window.btoa(binary);
        }
        
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        // Visualizer
        function drawVisualizer(buffer) {
            const data = new Float32Array(buffer);
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#4CAF50';
            ctx.beginPath();
            
            const sliceWidth = width / data.length;
            let x = 0;
            
            for (let i = 0; i < data.length; i++) {
                const v = data[i] * 50; // Amplify
                const y = height / 2 + v;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                x += sliceWidth;
            }
            
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // QUICK PROMPT BUTTONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        document.querySelectorAll('.quick-prompt-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const prompt = btn.dataset.prompt;
                if (prompt && ws && ws.readyState === WebSocket.OPEN && !isSystemSpeaking) {
                    // Add to chat
                    addMessage('user', prompt);
                    conversationHistory.push({ role: 'user', text: prompt });
                    
                    // Send as text (not audio)
                    ws.send(JSON.stringify({ 
                        type: 'text_input', 
                        text: prompt 
                    }));
                    
                    // Disable buttons briefly
                    document.querySelectorAll('.quick-prompt-btn').forEach(b => b.disabled = true);
                    setTimeout(() => {
                        document.querySelectorAll('.quick-prompt-btn').forEach(b => b.disabled = false);
                    }, 3000);
                }
            });
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // KEY TAKEAWAYS SUMMARY - Updates after every AI response
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const summaryPanel = document.getElementById('summary-panel');
        const summaryContent = document.getElementById('summary-content');
        let organizationName = 'the organization';
        
        async function updateSummary() {
            // Don't update if already pending or conversation too short
            if (summaryUpdatePending || conversationHistory.length < 2) return;
            
            summaryUpdatePending = true;
            
            // Show summary panel with loading state
            summaryPanel.classList.add('active');
            summaryContent.innerHTML = '<div class="summary-loading">Updating key takeaways</div>';
            
            try {
                // Build conversation transcript
                const transcript = conversationHistory.map(m => 
                    `${m.role === 'user' ? 'STUDENT' : 'COACH'}: ${m.text}`
                ).join('\n\n');
                
                // Call the summary API
                const response = await fetch('/api/generate-summary', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: sessionId,
                        transcript: transcript,
                        organization: organizationName,
                        turnCount: conversationHistory.length
                    })
                });
                
                if (!response.ok) throw new Error('Summary generation failed');
                
                const result = await response.json();
                
                // Update summary content with formatted HTML
                summaryContent.innerHTML = result.summaryHtml;
                
                // Show toggle button and summary panel after first successful summary
                document.getElementById('summary-toggle-panel').style.display = 'block';
                summaryPanel.classList.add('active');
                updateToggleButtonText();
                
                console.log('[SUMMARY] Updated with', conversationHistory.length, 'turns');
                
            } catch (error) {
                console.error('[SUMMARY] Error:', error);
                summaryContent.innerHTML = `
                    <div style="color: #888; text-align: center; padding: 20px;">
                        Summary will appear as the conversation develops...
                    </div>
                `;
            }
            
            summaryUpdatePending = false;
        }
        
        function toggleSummary() {
            summaryPanel.classList.toggle('active');
            updateToggleButtonText();
        }
        
        function updateToggleButtonText() {
            const btn = document.getElementById('summary-toggle-btn');
            const isActive = summaryPanel.classList.contains('active');
            btn.textContent = isActive ? 'üìã Hide Key Takeaways' : 'üìã Show Key Takeaways';
        }
        
        function printSummary() {
            window.print();
        }
        
        // Store organization name when context loads
        const originalWsOnMessage = ws?.onmessage;
        function enhanceWebSocketHandler() {
            const originalHandler = ws.onmessage;
            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                
                if (data.type === 'coaching_context_loaded' && data.organization) {
                    organizationName = data.organization;
                }
                
                // Call original handler
                if (originalHandler) {
                    await originalHandler(event);
                }
            };
        }
        
        // Also capture organization from upload result
        const originalUploadHandler = fileInput.onchange;
    </script>
</body>
</html>
